<!doctype html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>–î–µ—Ç—Å–∫–∞—è –∏–≥—Ä–∞-–ø–∞–∑–ª</title>
  <link rel="preconnect" href="https://cdnjs.cloudflare.com" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha512-SnH5WK+bZxgPHs44uWix+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkR4j8tbtS7zP1onhMGCdVK+iQrJ7lzPJQdA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <style>
    :root {
      --card: #ffffff;
      --accent: #5d8bff;
      --ok: #f6c945;
      --bad: #63c2a5;
      --text: #1f2b47;
      --shadow: 0 10px 25px rgba(31, 43, 71, 0.14);
      --radius: 18px;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Trebuchet MS", "Segoe UI", sans-serif;
      color: var(--text);
      background: radial-gradient(circle at top, #eaf2ff, #fef8ff 55%, #ffffff);
      min-height: 100vh;
    }
    .app {
      width: min(1220px, 95vw);
      margin: 18px auto 24px;
      background: rgba(255, 255, 255, 0.75);
      border: 2px solid #fff;
      border-radius: 24px;
      box-shadow: var(--shadow);
      padding: 14px;
    }
    .hud { display: flex; justify-content: space-between; align-items: center; gap: 12px; flex-wrap: wrap; padding: 8px 10px 14px; }
    .title { font-size: clamp(1.1rem, 2.8vw, 1.55rem); font-weight: 800; color: var(--accent); display:flex; gap:10px; align-items:center; }
    .score { display: flex; gap: 8px; flex-wrap: wrap; }
    .pill {
      background: var(--card);
      border-radius: 999px;
      padding: 9px 13px;
      border: 2px solid #edf2ff;
      font-weight: 700;
      min-width: 116px;
      text-align: center;
      box-shadow: 0 6px 16px rgba(60, 84, 133, 0.12);
      font-size: .95rem;
    }
    .difficulty-select {
      border-radius: 12px;
      border: 2px solid #d8e4ff;
      padding: 8px 10px;
      font-weight: 700;
      background: #fff;
      color: var(--text);
    }
    .rotation-toggle {
      border-radius: 12px;
      border: 2px solid #ffb8b8;
      padding: 9px 16px;
      font-weight: 800;
      background: #fff5f5;
      color: #d64444;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 0.95rem;
      box-shadow: 0 4px 12px rgba(214, 68, 68, 0.15);
    }
    .rotation-toggle:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(214, 68, 68, 0.22);
    }
    .rotation-toggle.active {
      border-color: #b8e6ff;
      background: #f0faff;
      color: #2d8cff;
      box-shadow: 0 4px 12px rgba(45, 140, 255, 0.15);
    }
    .rotation-toggle.active:hover {
      box-shadow: 0 6px 16px rgba(45, 140, 255, 0.22);
    }
    .layout { display: grid; grid-template-columns: minmax(260px, 360px) 1fr; gap: 14px; }
    .pieces-panel, .board-panel { background: var(--card); border-radius: var(--radius); border: 2px solid #e7edff; padding: 12px; position: relative; overflow: hidden; }
    .pieces-grid { display: grid; grid-template-columns: repeat(2, minmax(110px, 1fr)); gap: 10px; margin-top: 8px; }
    .piece-btn {
      border: 0; background: #f4f7ff; border-radius: 16px; min-height: 128px; cursor: pointer;
      transition: transform .2s ease, box-shadow .2s ease, background .2s ease;
      box-shadow: 0 6px 14px rgba(81,106,163,.16); display:grid; place-items:center;
    }
    .piece-btn:hover { transform: translateY(-3px); }
    .piece-btn.selected { outline: 3px solid var(--accent); background: #e7efff; transform: scale(1.03); }
    .piece-btn:disabled { cursor: default; opacity: .8; }
    .piece-btn canvas { width: min(92%, 150px); height:auto; pointer-events:none; transition: transform .6s cubic-bezier(.2,.65,.2,1); will-change: transform; filter: drop-shadow(0 4px 8px rgba(0,0,0,.2)); }
    .board-panel { min-height: 500px; display: flex; flex-direction: column; }
    #boardCanvas { width:100%; height:auto; aspect-ratio: 900 / 560; border-radius:16px; background: linear-gradient(140deg,#f5f8ff,#fefbff); border:2px dashed #d5def7; display:block; }
    .result-pop { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%) scale(.4); font-size:clamp(3rem,8vw,6rem); opacity:0; pointer-events:none; z-index:6; }
    .result-pop.show { animation: burst 1.1s ease forwards; }
    @keyframes burst {
      0% { opacity:0; transform:translate(-50%,-50%) scale(.2) rotate(-20deg); }
      20% { opacity:1; }
      60% { transform:translate(-50%,-50%) scale(1.15) rotate(12deg); }
      100% { opacity:0; transform:translate(-50%,-54%) scale(1.05) rotate(0deg); }
    }
    .overlay-message { position:fixed; inset:0; background:rgba(16,25,49,.55); display:grid; place-items:center; padding:16px; z-index:20; }
    .overlay-card { background:white; width:min(640px,96vw); border-radius:20px; padding:24px; text-align:center; box-shadow:var(--shadow); }
    .hidden { display:none !important; }
    @media (max-width: 900px) {
      .layout { grid-template-columns: 1fr; }
      .board-panel { min-height: 360px; }
      .pieces-grid { grid-template-columns: repeat(4, minmax(70px, 1fr)); }
      .piece-btn { min-height: 104px; }
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="hud">
      <div class="title"><i class="fa-solid fa-puzzle-piece"></i> –ù–∞–π–¥–∏ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –ø–∞–∑–ª!</div>
      <div class="score">
        <div class="pill">‚≠ê –í–µ—Ä–Ω–æ: <span id="okCount">0</span></div>
        <div class="pill">‚ùå –û—à–∏–±–∫–∏: <span id="badCount">0</span></div>
        <div class="pill">–†–∞—É–Ω–¥: <span id="roundNow">0</span>/<span id="roundTotal">0</span></div>
        <div class="pill">‚è±Ô∏è –í—Ä–µ–º—è: <span id="timerNow">0.0</span>—Å</div>
        <div class="pill">üèÜ –†–µ–∫–æ—Ä–¥: <span id="recordBest">‚Äî</span></div>
      </div>
      <div style="display: flex; gap: 10px; align-items: center;">
        <label for="difficultySelect"><strong>–°–ª–æ–∂–Ω–æ—Å—Ç—å:</strong></label>
        <select id="difficultySelect" class="difficulty-select">
          <option value="easy">–õ—ë–≥–∫–∞—è (4)</option>
          <option value="normal" selected>–û–±—ã—á–Ω–∞—è (6)</option>
          <option value="hard">–°–ª–æ–∂–Ω–∞—è (8)</option>
        </select>
        <button id="rotationToggle" class="rotation-toggle">‚ö†Ô∏è –õ—É—á—à–µ –Ω–µ –≤–∫–ª—é—á–∞–π!</button>
      </div>
    </div>

    <div class="layout">
      <section class="pieces-panel">
        <strong>–í—ã–±–µ—Ä–∏ –∫—É—Å–æ—á–µ–∫</strong>
        <div id="piecesGrid" class="pieces-grid"></div>
      </section>
      <section class="board-panel">
        <canvas id="boardCanvas" width="900" height="560"></canvas>
        <div id="resultPop" class="result-pop"></div>
      </section>
    </div>
  </div>

  <div id="overlay" class="overlay-message hidden"><div class="overlay-card" id="overlayCard"></div></div>

  <script>
    const SETTINGS = {
      rotationEnabled: false,
      rotationSpeed: 1.8,
      rotationInterval: 800,
      showDebugGrid: false,
      puzzleSize: 120,
      delayNext: 1500,
      difficultyOptions: { easy: 4, normal: 6, hard: 8 },
      recordStorageKey: 'kidsPuzzleRecordV1'
    };

    const state = {
      imagePaths: [],
      imageCache: new Map(),
      currentIndex: 0,
      right: 0,
      wrong: 0,
      currentRound: null,
      locked: false,
      rotationTimers: [],
      difficulty: 'normal',
      timerMs: 0,
      timerHandle: null,
      startedAt: 0,
      audioCtx: null,
      bestRecord: null
    };

    const boardCanvas = document.getElementById('boardCanvas');
    const boardCtx = boardCanvas.getContext('2d');
    const piecesGrid = document.getElementById('piecesGrid');
    const resultPop = document.getElementById('resultPop');
    const okCount = document.getElementById('okCount');
    const badCount = document.getElementById('badCount');
    const roundNow = document.getElementById('roundNow');
    const roundTotal = document.getElementById('roundTotal');
    const timerNow = document.getElementById('timerNow');
    const recordBest = document.getElementById('recordBest');
    const difficultySelect = document.getElementById('difficultySelect');
    const overlay = document.getElementById('overlay');
    const overlayCard = document.getElementById('overlayCard');

    function randomBetween(min, max) { return Math.random() * (max - min) + min; }

    function initAudio() {
      if (!state.audioCtx) {
        const Ctx = window.AudioContext || window.webkitAudioContext;
        if (Ctx) state.audioCtx = new Ctx();
      }
      if (state.audioCtx && state.audioCtx.state === 'suspended') state.audioCtx.resume();
    }

    function playFeedbackSound(ok) {
      if (!state.audioCtx) return;
      const ctx = state.audioCtx;
      const now = ctx.currentTime;
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = ok ? 'triangle' : 'sawtooth';
      osc.frequency.setValueAtTime(ok ? 720 : 260, now);
      osc.frequency.exponentialRampToValueAtTime(ok ? 1050 : 170, now + (ok ? 0.16 : 0.22));
      gain.gain.setValueAtTime(0.0001, now);
      gain.gain.exponentialRampToValueAtTime(0.18, now + 0.02);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + (ok ? 0.25 : 0.32));
      osc.connect(gain);
      gain.connect(ctx.destination);
      osc.start(now);
      osc.stop(now + (ok ? 0.26 : 0.34));
    }

    function formatSeconds(ms) { return (ms / 1000).toFixed(1); }

    function loadRecord() {
      try {
        const raw = localStorage.getItem(SETTINGS.recordStorageKey);
        state.bestRecord = raw ? JSON.parse(raw) : null;
      } catch (_) { state.bestRecord = null; }
      if (state.bestRecord?.right != null) {
        recordBest.textContent = `${state.bestRecord.right}/${state.bestRecord.total} –∑–∞ ${formatSeconds(state.bestRecord.timeMs)}—Å`;
      } else recordBest.textContent = '‚Äî';
    }

    function saveRecord(totalRounds) {
      const candidate = { right: state.right, total: totalRounds, timeMs: state.timerMs };
      const current = state.bestRecord;
      const isBetter = !current || candidate.right > current.right || (candidate.right === current.right && candidate.timeMs < current.timeMs);
      if (isBetter) {
        state.bestRecord = candidate;
        try { localStorage.setItem(SETTINGS.recordStorageKey, JSON.stringify(candidate)); } catch (_) {}
      }
      loadRecord();
      return isBetter;
    }

    function startTimer() {
      stopTimer();
      state.timerMs = 0;
      state.startedAt = performance.now();
      state.timerHandle = setInterval(() => {
        state.timerMs = performance.now() - state.startedAt;
        timerNow.textContent = formatSeconds(state.timerMs);
      }, 100);
    }

    function stopTimer() {
      if (state.timerHandle) clearInterval(state.timerHandle);
      state.timerHandle = null;
    }

    async function loadImages() {
      let list;
      try {
        const response = await fetch('./img/list.json', { cache: 'no-store' });
        if (!response.ok) throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å img/list.json');
        list = await response.json();
      } catch (error) {
        showOverlay(`<h2>–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è</h2><p>–ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Ñ–∞–π–ª <code>img/list.json</code>.</p><p><small>${error.message}</small></p>`);
        return;
      }

      const files = Array.isArray(list?.images) ? list.images : [];
      if (!files.length) {
        showOverlay('<h2>–ü–∞–ø–∫–∞ img –ø—É—Å—Ç–∞</h2><p>–î–æ–±–∞–≤—å—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏ –∑–∞–ø–æ–ª–Ω–∏—Ç–µ <code>img/list.json</code>.</p>');
        return;
      }

      const loaded = (await Promise.all(files.map((name) => new Promise((resolve) => {
        const path = `./img/${name}`;
        const img = new Image();
        img.onload = () => { state.imageCache.set(path, img); resolve(path); };
        img.onerror = () => resolve(null);
        img.src = path;
      })))).filter(Boolean);

      state.imagePaths = loaded;
      if (!state.imagePaths.length) {
        showOverlay('<h2>–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –Ω–µ –∑–∞–≥—Ä—É–∑–∏–ª–∏—Å—å</h2><p>–ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Ñ–æ—Ä–º–∞—Ç—ã JPG/PNG –≤ –ø–∞–ø–∫–µ <code>img</code>.</p>');
        return;
      }

      roundTotal.textContent = state.imagePaths.length;
      overlay.classList.add('hidden');
      loadRecord();
      startNewGame();
    }

    function createJigsawPath(size, padding) {
      const x = padding, y = padding;
      const t = size * 0.22, neck = size * 0.12, mid = size / 2;
      const dirs = [0,1,2,3].map(() => (Math.random() > 0.5 ? 1 : -1));
      const p = new Path2D();
      p.moveTo(x, y);
      p.lineTo(x + mid - neck, y);
      p.bezierCurveTo(x + mid - neck, y - t * dirs[0], x + mid + neck, y - t * dirs[0], x + mid + neck, y);
      p.lineTo(x + size, y);
      p.lineTo(x + size, y + mid - neck);
      p.bezierCurveTo(x + size + t * dirs[1], y + mid - neck, x + size + t * dirs[1], y + mid + neck, x + size, y + mid + neck);
      p.lineTo(x + size, y + size);
      p.lineTo(x + mid + neck, y + size);
      p.bezierCurveTo(x + mid + neck, y + size + t * dirs[2], x + mid - neck, y + size + t * dirs[2], x + mid - neck, y + size);
      p.lineTo(x, y + size);
      p.lineTo(x, y + mid + neck);
      p.bezierCurveTo(x - t * dirs[3], y + mid + neck, x - t * dirs[3], y + mid - neck, x, y + mid - neck);
      p.closePath();
      return { path: p, tabSize: t };
    }

    function createPuzzle(image) {
      const viewW = boardCanvas.width, viewH = boardCanvas.height, size = SETTINGS.puzzleSize;
      const fit = Math.min(viewW / image.naturalWidth, viewH / image.naturalHeight);
      const drawW = image.naturalWidth * fit, drawH = image.naturalHeight * fit;
      const dx = (viewW - drawW) / 2, dy = (viewH - drawH) / 2;

      const holeX = randomBetween(dx + size * 0.5, dx + drawW - size * 1.5);
      const holeY = randomBetween(dy + size * 0.5, dy + drawH - size * 1.5);

      const padding = Math.round(size * 0.28);
      const shape = createJigsawPath(size, padding);
      const fragmentSize = size + padding * 2;
      const count = SETTINGS.difficultyOptions[state.difficulty] || 6;
      const correctId = Math.floor(Math.random() * count);

      const fragments = Array.from({ length: count }, (_, i) => {
        const isCorrect = i === correctId;
        const sx = isCorrect ? holeX : randomBetween(dx + size * 0.2, dx + drawW - size * 1.2);
        const sy = isCorrect ? holeY : randomBetween(dy + size * 0.2, dy + drawH - size * 1.2);
        return { id: i, sx, sy, isCorrect, fragmentSize, padding, path: shape.path };
      });

      return { image, drawRect: { dx, dy, drawW, drawH }, hole: { x: holeX, y: holeY, path: shape.path, padding }, fragments, correctId };
    }

    function drawBoard(round) {
      boardCtx.clearRect(0, 0, boardCanvas.width, boardCanvas.height);
      const { dx, dy, drawW, drawH } = round.drawRect;
      boardCtx.drawImage(round.image, dx, dy, drawW, drawH);

      boardCtx.save();
      boardCtx.translate(round.hole.x - round.hole.padding, round.hole.y - round.hole.padding);
      boardCtx.globalCompositeOperation = 'destination-out';
      boardCtx.fillStyle = '#000';
      boardCtx.fill(round.hole.path);
      boardCtx.restore();

      boardCtx.save();
      boardCtx.translate(round.hole.x - round.hole.padding, round.hole.y - round.hole.padding);
      // –ü–æ—Ç–µ–º–Ω–µ–µ –¥–ª—è –ª—É—á—à–µ–≥–æ –∫–æ–Ω—Ç—Ä–∞—Å—Ç–∞
      boardCtx.strokeStyle = 'rgba(31,43,71,.9)';
      boardCtx.lineWidth = 4;
      boardCtx.setLineDash([10, 6]);
      boardCtx.stroke(round.hole.path);
      boardCtx.restore();

      if (SETTINGS.showDebugGrid) {
        boardCtx.save();
        boardCtx.strokeStyle = 'rgba(55,93,180,.32)';
        boardCtx.lineWidth = 1;
        for (let x = 0; x < boardCanvas.width; x += 40) { boardCtx.beginPath(); boardCtx.moveTo(x, 0); boardCtx.lineTo(x, boardCanvas.height); boardCtx.stroke(); }
        for (let y = 0; y < boardCanvas.height; y += 40) { boardCtx.beginPath(); boardCtx.moveTo(0, y); boardCtx.lineTo(boardCanvas.width, y); boardCtx.stroke(); }
        boardCtx.restore();
      }
    }

    function drawPieceCanvas(round, fragment) {
      const c = document.createElement('canvas');
      c.width = fragment.fragmentSize;
      c.height = fragment.fragmentSize;
      const ctx = c.getContext('2d');
      ctx.clearRect(0, 0, c.width, c.height);

      ctx.save();
      ctx.clip(fragment.path);
      const srcX = fragment.sx - fragment.padding;
      const srcY = fragment.sy - fragment.padding;
      const { dx, dy, drawW, drawH } = round.drawRect;
      ctx.drawImage(round.image, dx - srcX, dy - srcY, drawW, drawH);
      ctx.restore();

      ctx.strokeStyle = 'rgba(255,255,255,.95)';
      ctx.lineWidth = 3;
      ctx.stroke(fragment.path);
      ctx.strokeStyle = 'rgba(31,43,71,.25)';
      ctx.lineWidth = 1;
      ctx.stroke(fragment.path);
      return c;
    }

    function clearRotations() { state.rotationTimers.forEach(clearInterval); state.rotationTimers = []; }

    function animateRotation() {
      clearRotations();
      if (!SETTINGS.rotationEnabled) return;
      const canvases = Array.from(piecesGrid.querySelectorAll('.piece-btn canvas'));
      canvases.forEach((canvas) => {
        let angle = randomBetween(-90, 90);
        canvas.style.transform = `rotate(${angle}deg)`;
        const tick = () => {
          const turns = randomBetween(1.5, 2.5) * SETTINGS.rotationSpeed;
          const direction = Math.random() > 0.5 ? 1 : -1;
          angle += turns * 360 * direction;
          canvas.style.transitionDuration = `${randomBetween(0.22, 0.48) / SETTINGS.rotationSpeed}s`;
          canvas.style.transform = `rotate(${angle}deg)`;
        };
        tick();
        const timer = setInterval(tick, SETTINGS.rotationInterval + randomBetween(-170, 220));
        state.rotationTimers.push(timer);
      });
    }

    function renderGame() {
      state.locked = false;
      clearRotations();
      const image = state.imageCache.get(state.imagePaths[state.currentIndex]);
      if (!image) return nextRound();

      state.currentRound = createPuzzle(image);
      drawBoard(state.currentRound);
      piecesGrid.innerHTML = '';

      state.currentRound.fragments.forEach((fragment) => {
        const btn = document.createElement('button');
        btn.className = 'piece-btn';
        btn.dataset.id = String(fragment.id);
        btn.appendChild(drawPieceCanvas(state.currentRound, fragment));
        btn.addEventListener('click', () => handleChoice(fragment.id, btn));
        piecesGrid.appendChild(btn);
      });

      okCount.textContent = String(state.right);
      badCount.textContent = String(state.wrong);
      roundNow.textContent = String(state.currentIndex + 1);
      animateRotation();
    }

    function showResult(iconClass, color) {
      resultPop.innerHTML = `<i class="${iconClass}"></i>`;
      resultPop.style.color = color;
      resultPop.classList.remove('show');
      void resultPop.offsetWidth;
      resultPop.classList.add('show');
    }

    function handleChoice(id, buttonEl) {
      initAudio();
      if (state.locked || !state.currentRound) return;
      state.locked = true;
      Array.from(piecesGrid.children).forEach((node) => node.setAttribute('disabled', 'true'));
      buttonEl.classList.add('selected');

      const hit = id === state.currentRound.correctId;
      playFeedbackSound(hit);
      if (hit) {
        state.right += 1;
        showResult('fa-solid fa-star', 'var(--ok)');
      } else {
        state.wrong += 1;
        showResult('fa-solid fa-bandage', 'var(--bad)');
      }

      okCount.textContent = String(state.right);
      badCount.textContent = String(state.wrong);
      setTimeout(nextRound, SETTINGS.delayNext);
    }

    function nextRound() {
      clearRotations();
      state.currentIndex += 1;
      if (state.currentIndex >= state.imagePaths.length) return finishGame();
      renderGame();
    }

    function showOverlay(html) {
      overlayCard.innerHTML = html;
      overlay.classList.remove('hidden');
    }

    function startNewGame() {
      stopTimer();
      state.currentIndex = 0;
      state.right = 0;
      state.wrong = 0;
      timerNow.textContent = '0.0';
      overlay.classList.add('hidden');
      startTimer();
      renderGame();
    }

    function finishGame() {
      stopTimer();
      boardCtx.clearRect(0, 0, boardCanvas.width, boardCanvas.height);
      piecesGrid.innerHTML = '';
      const isNewRecord = saveRecord(state.imagePaths.length);
      showOverlay(
        `<h2>–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞ üéâ</h2>
         <p style="font-size:1.2rem;">‚≠ê –ü—Ä–∞–≤–∏–ª—å–Ω—ã—Ö –æ—Ç–≤–µ—Ç–æ–≤: <b>${state.right}</b> / ${state.imagePaths.length}</p>
         <p style="font-size:1.2rem;">‚ùå –û—à–∏–±–æ–∫: <b>${state.wrong}</b></p>
         <p style="font-size:1.2rem;">‚è±Ô∏è –í—Ä–µ–º—è: <b>${formatSeconds(state.timerMs)}—Å</b></p>
         ${isNewRecord ? '<p style="color:#2f7d32;font-weight:800;">üèÜ –ù–æ–≤—ã–π —Ä–µ–∫–æ—Ä–¥!</p>' : ''}
         <button id="restartBtn" style="margin-top:14px;padding:12px 18px;border-radius:14px;border:none;background:#5d8bff;color:#fff;font-weight:800;cursor:pointer;">–ò–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞</button>`
      );
      const restart = document.getElementById('restartBtn');
      if (restart) restart.addEventListener('click', startNewGame, { once: true });
    }

    difficultySelect.addEventListener('change', () => {
      state.difficulty = difficultySelect.value;
      if (state.imagePaths.length) startNewGame();
    });

    const rotationToggle = document.getElementById('rotationToggle');
    rotationToggle.addEventListener('click', () => {
      SETTINGS.rotationEnabled = !SETTINGS.rotationEnabled;
      if (SETTINGS.rotationEnabled) {
        rotationToggle.textContent = '‚Üª –í–µ—Ä–Ω–∏ –≤—Å—ë –∫–∞–∫ –±—ã–ª–æ!';
        rotationToggle.classList.add('active');
      } else {
        rotationToggle.textContent = '‚ö†Ô∏è –õ—É—á—à–µ –Ω–µ –≤–∫–ª—é—á–∞–π!';
        rotationToggle.classList.remove('active');
      }
      animateRotation();
    });

    window.addEventListener('resize', () => {
      if (!state.currentRound || state.locked) return;
      drawBoard(state.currentRound);
    });

    loadImages();
  </script>
</body>
</html>
